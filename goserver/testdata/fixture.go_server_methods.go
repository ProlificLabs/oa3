// Code generated by oa3 (https://github.com/aarondl/oa3). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.
package oa3gen

import (
	"errors"
	"net/http"

	"github.com/aarondl/oa3/support"
	"github.com/aarondl/opt/null"
	"github.com/aarondl/opt/omit"
	"github.com/aarondl/opt/omitnull"
)

// AlreadyHandled is an interface which an error return type can optionally
// implement to stop the generated method from responding in anyway, it will
// swallow the error and not touch the ResponseWriter if this method returns
// true.
type AlreadyHandled interface {
	AlreadyHandled() bool
}

// ErrHandled is a sentinel error that implements
// the AlreadyHandled interface which prevents the
// generated handler from firing.
type ErrHandled struct{}

// Error implements error
func (ErrHandled) Error() string { return "already handled" }

// AlreadyHandled implements AlreadyHandled
func (ErrHandled) AlreadyHandled() bool { return true }

// authenticate post /auth
func (o GoServer) authenticateOp(w http.ResponseWriter, r *http.Request) error {
	var err error
	var ers []error
	var errs map[string][]string
	_, _, _ = err, ers, errs

	if errs != nil {
		return o.converter(errs)
	}

	ret, err := o.impl.Authenticate(w, r)
	if err != nil {
		if alreadyHandled, ok := err.(AlreadyHandled); ok {
			if alreadyHandled.AlreadyHandled() {
				return nil
			}
		}
		return err
	}

	switch respBody := ret.(type) {
	case HTTPStatusOk:
		w.WriteHeader(200)
	default:
		_ = respBody
		panic("impossible case")
	}

	return nil
}

// testinlineprimitivebody get /test/inline
func (o GoServer) testinlineprimitivebodyOp(w http.ResponseWriter, r *http.Request) error {
	var err error
	var ers []error
	var errs map[string][]string
	_, _, _ = err, ers, errs

	var reqBody TestInlinePrimitiveBodyInline

	if r.Body == nil {
		return support.ErrNoBody
	} else {
		if err = support.ReadJSON(r, &reqBody); err != nil {
			return err
		}

		if newErrs := reqBody.VVValidateSchema(); newErrs != nil {
			errs = support.MergeErrs(errs, newErrs)
		}
	}

	if errs != nil {
		return o.converter(errs)
	}

	ret, err := o.impl.TestInlinePrimitiveBody(w, r, string(reqBody))
	if err != nil {
		if alreadyHandled, ok := err.(AlreadyHandled); ok {
			if alreadyHandled.AlreadyHandled() {
				return nil
			}
		}
		return err
	}

	switch respBody := ret.(type) {
	case HTTPStatusOk:
		w.WriteHeader(200)
	default:
		_ = respBody
		panic("impossible case")
	}

	return nil
}

// testinline post /test/inline
func (o GoServer) testinlineOp(w http.ResponseWriter, r *http.Request) error {
	var err error
	var ers []error
	var errs map[string][]string
	_, _, _ = err, ers, errs

	var reqBody TestInlineInline

	if r.Body == nil {
		return support.ErrNoBody
	} else {
		if err = support.ReadJSON(r, &reqBody); err != nil {
			return err
		}

		if newErrs := reqBody.VVValidateSchema(); newErrs != nil {
			errs = support.MergeErrs(errs, newErrs)
		}
	}

	if errs != nil {
		return o.converter(errs)
	}

	ret, err := o.impl.TestInline(w, r, reqBody)
	if err != nil {
		if alreadyHandled, ok := err.(AlreadyHandled); ok {
			if alreadyHandled.AlreadyHandled() {
				return nil
			}
		}
		return err
	}

	switch respBody := ret.(type) {
	case TestInline200Inline:
		w.WriteHeader(200)

		if err := support.WriteJSON(w, respBody); err != nil {
			return err
		}
	case TestInline201Inline:
		w.WriteHeader(201)

		if err := support.WriteJSON(w, respBody); err != nil {
			return err
		}
	default:
		_ = respBody
		panic("impossible case")
	}

	return nil
}

// getuser get /users/{id}
func (o GoServer) getuserOp(w http.ResponseWriter, r *http.Request) error {
	var err error
	var ers []error
	var errs map[string][]string
	_, _, _ = err, ers, errs

	const n0 = `valid_str`
	s0 := r.URL.Query().Get(n0)
	var p0 omitnull.Val[string]
	if len(s0) != 0 {
		if s0 == "null" {
			p0.Null()
		} else {
			p0.Set(s0)
		}
		err = nil
		if err != nil {
			errs = support.AddErrs(errs, n0, errors.New(`was not in a valid format`))
		}
		ers = nil
		if err := support.ValidateMaxLength(omitnull.Val[string](p0).GetOrZero(), 5); err != nil {
			ers = append(ers, err)
		}

		if err := support.ValidateMinLength(omitnull.Val[string](p0).GetOrZero(), 2); err != nil {
			ers = append(ers, err)
		}
		if err := support.ValidateEnum(omitnull.Val[string](p0).GetOrZero(), []string{"he\"llo"}); err != nil {
			ers = append(ers, err)
		}

		if len(ers) != 0 {
			errs = support.AddErrs(errs, n0, ers...)
		}
	}

	const n1 = `req_valid_str`
	s1 := r.URL.Query().Get(n1)
	var p1 null.Val[string]
	if len(s1) == 0 {
		errs = support.AddErrs(errs, n1, errors.New(`must not be empty`))
	} else {
		if s0 == "null" {
			p1.Null()
		} else {
			p1.Set(s0)
		}
		err = nil
		if err != nil {
			errs = support.AddErrs(errs, n1, errors.New(`was not in a valid format`))
		}
		ers = nil
		if err := support.ValidateMaxLength(null.Val[string](p1).GetOrZero(), 5); err != nil {
			ers = append(ers, err)
		}

		if err := support.ValidateMinLength(null.Val[string](p1).GetOrZero(), 2); err != nil {
			ers = append(ers, err)
		}
		if err := support.ValidateEnum(null.Val[string](p1).GetOrZero(), []string{"he\"llo"}); err != nil {
			ers = append(ers, err)
		}

		if len(ers) != 0 {
			errs = support.AddErrs(errs, n1, ers...)
		}
	}

	const n2 = `valid_int`
	s2 := r.URL.Query().Get(n2)
	var p2 omit.Val[int]
	if len(s2) != 0 {
		p2c, err := support.StringToInt[int](s2, 64)
		p2.Set(p2c)
		if err != nil {
			errs = support.AddErrs(errs, n2, errors.New(`was not in a valid format`))
		}
		ers = nil
		if err := support.ValidateMaxNumber(p2.GetOrZero(), 5, true); err != nil {
			ers = append(ers, err)
		}
		if err := support.ValidateMinNumber(p2.GetOrZero(), 2, false); err != nil {
			ers = append(ers, err)
		}
		if err := support.ValidateMultipleOfInt(p2.GetOrZero(), 2); err != nil {
			ers = append(ers, err)
		}
		if len(ers) != 0 {
			errs = support.AddErrs(errs, n2, ers...)
		}
	}

	const n3 = `req_valid_int`
	s3 := r.URL.Query().Get(n3)
	var p3 int
	if len(s3) == 0 {
		errs = support.AddErrs(errs, n3, errors.New(`must not be empty`))
	} else {
		p3, err = support.StringToInt[int](s3, 64)
		if err != nil {
			errs = support.AddErrs(errs, n3, errors.New(`was not in a valid format`))
		}
		ers = nil
		if err := support.ValidateMaxNumber(p3, 5, true); err != nil {
			ers = append(ers, err)
		}
		if err := support.ValidateMinNumber(p3, 2, false); err != nil {
			ers = append(ers, err)
		}
		if err := support.ValidateMultipleOfInt(p3, 2); err != nil {
			ers = append(ers, err)
		}
		if len(ers) != 0 {
			errs = support.AddErrs(errs, n3, ers...)
		}
	}

	const n4 = `valid_num`
	s4 := r.URL.Query().Get(n4)
	var p4 omit.Val[float64]
	if len(s4) != 0 {
		p4c, err := support.StringToFloat[float64](s4, 64)
		p4.Set(p4c)
		if err != nil {
			errs = support.AddErrs(errs, n4, errors.New(`was not in a valid format`))
		}
		ers = nil
		if err := support.ValidateMaxNumber(p4.GetOrZero(), 10.5, false); err != nil {
			ers = append(ers, err)
		}
		if err := support.ValidateMinNumber(p4.GetOrZero(), 5.5, true); err != nil {
			ers = append(ers, err)
		}
		if err := support.ValidateMultipleOfFloat(p4.GetOrZero(), 2.5); err != nil {
			ers = append(ers, err)
		}
		if len(ers) != 0 {
			errs = support.AddErrs(errs, n4, ers...)
		}
	}

	const n5 = `req_valid_num`
	s5 := r.URL.Query().Get(n5)
	var p5 float64
	if len(s5) == 0 {
		errs = support.AddErrs(errs, n5, errors.New(`must not be empty`))
	} else {
		p5, err = support.StringToFloat[float64](s5, 64)
		if err != nil {
			errs = support.AddErrs(errs, n5, errors.New(`was not in a valid format`))
		}
		ers = nil
		if err := support.ValidateMaxNumber(p5, 10.5, false); err != nil {
			ers = append(ers, err)
		}
		if err := support.ValidateMinNumber(p5, 5.5, true); err != nil {
			ers = append(ers, err)
		}
		if err := support.ValidateMultipleOfFloat(p5, 2.5); err != nil {
			ers = append(ers, err)
		}
		if len(ers) != 0 {
			errs = support.AddErrs(errs, n5, ers...)
		}
	}

	const n6 = `valid_bool`
	s6 := r.URL.Query().Get(n6)
	var p6 omit.Val[bool]
	if len(s6) != 0 {
		if err != nil {
			errs = support.AddErrs(errs, n6, errors.New(`was not in a valid format`))
		}
	}

	const n7 = `req_valid_bool`
	s7 := r.URL.Query().Get(n7)
	var p7 bool
	if len(s7) == 0 {
		errs = support.AddErrs(errs, n7, errors.New(`must not be empty`))
	} else {
		p7, err = support.StringToBool(s7)
		if err != nil {
			errs = support.AddErrs(errs, n7, errors.New(`was not in a valid format`))
		}
	}

	const n8 = `req_str_format`
	s8 := r.URL.Query().Get(n8)
	var p8 string
	if len(s8) == 0 {
		errs = support.AddErrs(errs, n8, errors.New(`must not be empty`))
	} else {
		p8 = s8
		ers = nil
		if err := support.ValidateFormatUUIDv4(p8); err != nil {
			ers = append(ers, err)
		}

		if len(ers) != 0 {
			errs = support.AddErrs(errs, n8, ers...)
		}
	}

	if errs != nil {
		return o.converter(errs)
	}

	ret, err := o.impl.GetUser(w, r, p0, p1, p2, p3, p4, p5, p6, p7, p8)
	if err != nil {
		if alreadyHandled, ok := err.(AlreadyHandled); ok {
			if alreadyHandled.AlreadyHandled() {
				return nil
			}
		}
		return err
	}

	switch respBody := ret.(type) {
	case HTTPStatusNotModified:
		w.WriteHeader(304)
	default:
		_ = respBody
		panic("impossible case")
	}

	return nil
}

// setuser post /users/{id}
func (o GoServer) setuserOp(w http.ResponseWriter, r *http.Request) error {
	var err error
	var ers []error
	var errs map[string][]string
	_, _, _ = err, ers, errs

	var reqBody Primitives

	if r.Body == nil {
		return support.ErrNoBody
	} else {
		if err = support.ReadJSON(r, &reqBody); err != nil {
			return err
		}

		if newErrs := reqBody.VVValidateSchema(); newErrs != nil {
			errs = support.MergeErrs(errs, newErrs)
		}
	}

	if errs != nil {
		return o.converter(errs)
	}

	ret, err := o.impl.SetUser(w, r, &reqBody)
	if err != nil {
		if alreadyHandled, ok := err.(AlreadyHandled); ok {
			if alreadyHandled.AlreadyHandled() {
				return nil
			}
		}
		return err
	}

	switch respBody := ret.(type) {
	case SetUser200WrappedResponse:
		headers := w.Header()
		if val, ok := respBody.HeaderXResponseHeader.Get(); ok {
			headers.Set("X-Response-Header", val)
		}
		w.WriteHeader(200)
		if err := support.WriteJSON(w, respBody); err != nil {
			return err
		}
	case SetUserdefaultWrappedResponse:

		if err := support.WriteJSON(w, respBody); err != nil {
			return err
		}
	default:
		_ = respBody
		panic("impossible case")
	}

	return nil
}
