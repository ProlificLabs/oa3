// Code generated by oa3 (https://github.com/aarondl/oa3). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.
package oa3gen

import (
	"strings"

	"github.com/aarondl/oa3/support"
	"github.com/aarondl/opt/null"
)

// Checks to see that all Go primitives work
type Primitives struct {
	Bool        bool              `json:"bool"`
	BoolNull    null.Val[bool]    `json:"bool_null"`
	Float       float64           `json:"float"`
	Float32     float32           `json:"float32"`
	Float32Null null.Val[float32] `json:"float32_null"`
	Float64     float64           `json:"float64"`
	Float64Null null.Val[float64] `json:"float64_null"`
	FloatNull   null.Val[float64] `json:"float_null"`
	// Normal int
	Int       int               `json:"int"`
	Int32     int32             `json:"int32"`
	Int32Null null.Val[int32]   `json:"int32_null"`
	Int64     int64             `json:"int64"`
	Int64Null null.Val[int64]   `json:"int64_null"`
	IntNull   null.Val[int]     `json:"int_null"`
	Str       PrimitivesStr     `json:"str"`
	StrFormat string            `json:"str_format"`
	StrNull   PrimitivesStrNull `json:"str_null"`
}
type PrimitivesStr string

const (
	PrimitivesStrHello PrimitivesStr = "hello"
)

type PrimitivesStrNull null.Val[string]

var (
	PrimitivesStrNullHello PrimitivesStrNull = PrimitivesStrNull(null.From("hello"))
)

// VVValidateSchemaPrimitives validates the object and returns
// errors that can be returned to the user.
func (o Primitives) VVValidateSchema() support.Errors {
	var ctx []string
	var ers []error
	var errs support.Errors
	_, _, _ = ctx, ers, errs

	// VALIDATING float false true
	ers = nil
	if err := support.ValidateMultipleOfFloat(o.Float, 5.5); err != nil {
		ers = append(ers, err)
	}
	if len(ers) != 0 {
		ctx = append(ctx, "float")
		errs = support.AddErrs(errs, strings.Join(ctx, "."), ers...)
		ctx = ctx[:len(ctx)-1]
	}
	// VALIDATING float32 false true
	ers = nil
	if err := support.ValidateMaxNumber(o.Float32, 5.5, false); err != nil {
		ers = append(ers, err)
	}
	if len(ers) != 0 {
		ctx = append(ctx, "float32")
		errs = support.AddErrs(errs, strings.Join(ctx, "."), ers...)
		ctx = ctx[:len(ctx)-1]
	}
	// VALIDATING float32_null true true
	ers = nil
	if err := support.ValidateMaxNumber(o.Float32Null.GetOrZero(), 5, false); err != nil {
		ers = append(ers, err)
	}
	if len(ers) != 0 {
		ctx = append(ctx, "float32_null")
		errs = support.AddErrs(errs, strings.Join(ctx, "."), ers...)
		ctx = ctx[:len(ctx)-1]
	}
	// VALIDATING float64 false true
	ers = nil
	if err := support.ValidateMinNumber(o.Float64, 5.5, false); err != nil {
		ers = append(ers, err)
	}
	if len(ers) != 0 {
		ctx = append(ctx, "float64")
		errs = support.AddErrs(errs, strings.Join(ctx, "."), ers...)
		ctx = ctx[:len(ctx)-1]
	}
	// VALIDATING float64_null true true
	ers = nil
	if err := support.ValidateMinNumber(o.Float64Null.GetOrZero(), 5, false); err != nil {
		ers = append(ers, err)
	}
	if len(ers) != 0 {
		ctx = append(ctx, "float64_null")
		errs = support.AddErrs(errs, strings.Join(ctx, "."), ers...)
		ctx = ctx[:len(ctx)-1]
	}
	// VALIDATING float_null true true
	ers = nil
	if err := support.ValidateMultipleOfFloat(o.FloatNull.GetOrZero(), 5.5); err != nil {
		ers = append(ers, err)
	}
	if len(ers) != 0 {
		ctx = append(ctx, "float_null")
		errs = support.AddErrs(errs, strings.Join(ctx, "."), ers...)
		ctx = ctx[:len(ctx)-1]
	}
	// VALIDATING int false true
	ers = nil
	if err := support.ValidateMultipleOfInt(o.Int, 5); err != nil {
		ers = append(ers, err)
	}
	if len(ers) != 0 {
		ctx = append(ctx, "int")
		errs = support.AddErrs(errs, strings.Join(ctx, "."), ers...)
		ctx = ctx[:len(ctx)-1]
	}
	// VALIDATING int32 false true
	ers = nil
	if err := support.ValidateMaxNumber(o.Int32, 5, false); err != nil {
		ers = append(ers, err)
	}
	if len(ers) != 0 {
		ctx = append(ctx, "int32")
		errs = support.AddErrs(errs, strings.Join(ctx, "."), ers...)
		ctx = ctx[:len(ctx)-1]
	}
	// VALIDATING int32_null true true
	ers = nil
	if err := support.ValidateMaxNumber(o.Int32Null.GetOrZero(), 5, false); err != nil {
		ers = append(ers, err)
	}
	if len(ers) != 0 {
		ctx = append(ctx, "int32_null")
		errs = support.AddErrs(errs, strings.Join(ctx, "."), ers...)
		ctx = ctx[:len(ctx)-1]
	}
	// VALIDATING int64 false true
	ers = nil
	if err := support.ValidateMinNumber(o.Int64, 5, false); err != nil {
		ers = append(ers, err)
	}
	if len(ers) != 0 {
		ctx = append(ctx, "int64")
		errs = support.AddErrs(errs, strings.Join(ctx, "."), ers...)
		ctx = ctx[:len(ctx)-1]
	}
	// VALIDATING int64_null true true
	ers = nil
	if err := support.ValidateMinNumber(o.Int64Null.GetOrZero(), 5, false); err != nil {
		ers = append(ers, err)
	}
	if len(ers) != 0 {
		ctx = append(ctx, "int64_null")
		errs = support.AddErrs(errs, strings.Join(ctx, "."), ers...)
		ctx = ctx[:len(ctx)-1]
	}
	// VALIDATING int_null true true
	ers = nil
	if err := support.ValidateMultipleOfInt(o.IntNull.GetOrZero(), 5); err != nil {
		ers = append(ers, err)
	}
	if len(ers) != 0 {
		ctx = append(ctx, "int_null")
		errs = support.AddErrs(errs, strings.Join(ctx, "."), ers...)
		ctx = ctx[:len(ctx)-1]
	}
	// VALIDATING str false true
	ers = nil
	if err := support.ValidateMaxLength(o.Str, 5); err != nil {
		ers = append(ers, err)
	}

	if err := support.ValidateMinLength(o.Str, 5); err != nil {
		ers = append(ers, err)
	}
	if err := support.ValidateEnum(o.Str, []string{"hello"}); err != nil {
		ers = append(ers, err)
	}

	if len(ers) != 0 {
		ctx = append(ctx, "str")
		errs = support.AddErrs(errs, strings.Join(ctx, "."), ers...)
		ctx = ctx[:len(ctx)-1]
	}
	// VALIDATING str_format false true
	ers = nil
	if err := support.ValidateFormatUUIDv4(o.StrFormat); err != nil {
		ers = append(ers, err)
	}

	if len(ers) != 0 {
		ctx = append(ctx, "str_format")
		errs = support.AddErrs(errs, strings.Join(ctx, "."), ers...)
		ctx = ctx[:len(ctx)-1]
	}
	// VALIDATING str_null true true
	ers = nil
	if err := support.ValidateMaxLength(null.Val[string](o.StrNull).GetOrZero(), 5); err != nil {
		ers = append(ers, err)
	}

	if err := support.ValidateMinLength(null.Val[string](o.StrNull).GetOrZero(), 5); err != nil {
		ers = append(ers, err)
	}
	if err := support.ValidateEnum(null.Val[string](o.StrNull).GetOrZero(), []string{"hello"}); err != nil {
		ers = append(ers, err)
	}

	if len(ers) != 0 {
		ctx = append(ctx, "str_null")
		errs = support.AddErrs(errs, strings.Join(ctx, "."), ers...)
		ctx = ctx[:len(ctx)-1]
	}

	return errs
}
